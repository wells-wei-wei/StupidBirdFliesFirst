网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

<!-- TOC -->

- [1. UDP 和 TCP 的特点](#1-udp-和-tcp-的特点)
- [2. UDP和TCP区别](#2-udp和tcp区别)
- [3. UDP 首部格式](#3-udp-首部格式)
- [4. TCP 首部格式](#4-tcp-首部格式)
- [5. TCP 的三次握手和四次挥手](#5-tcp-的三次握手和四次挥手)
  - [5.1. TCP协议连接的建立和解除](#51-tcp协议连接的建立和解除)
    - [5.1.1. 概念性讲解](#511-概念性讲解)
  - [5.2. TCP 三次握手详解](#52-tcp-三次握手详解)
  - [5.3. TCP四次挥手](#53-tcp四次挥手)
  - [5.4. TCP状态转移](#54-tcp状态转移)
  - [5.5. TIME_WAIT状态](#55-time_wait状态)
  - [5.6. 为什么“握手”是三次，“挥手”却要四次？](#56-为什么握手是三次挥手却要四次)
- [6. TCP 可靠传输](#6-tcp-可靠传输)
- [7. TCP 滑动窗口](#7-tcp-滑动窗口)
- [8. TCP 流量控制](#8-tcp-流量控制)
- [9. TCP 拥塞控制](#9-tcp-拥塞控制)
  - [9.1. 慢开始与拥塞避免](#91-慢开始与拥塞避免)
  - [9.2. 快重传与快恢复](#92-快重传与快恢复)

<!-- /TOC -->

# 1. UDP 和 TCP 的特点

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的（使用UDP协议的发送者和接受者之间不必存在任何长期的关系。 它们没有建立连接过程，整个消息传输过程简单来说就是“发送即结束”），尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信。UDP的发送端应用程序没执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送，接收端必须及时针对每一个UDP数据报执行读操作，否则就会丢包，且如果用户没有指定足够的应用程序缓冲区来读取UDP数据，UDP数据就会被截断。

- 传输控制协议TCP（Transmission Control Protocol）
  - 面向连接
    1. 使用TCP连接的双方必须建立连接，双方必须为连接分配必要的内核资源，以管理连接状态和连接上的数据传输。
    2. TCP连接时全双工的
    3. 完成数据交换以后通信双方需要断开连接以释放系统资源
    4. TCP连接是一对一的，所以广播和多播不用使用TCP（可以用UDP）
  - 字节流
    字节流其实就是在写入数据时，TCP模块先将数据放入TCP发送缓冲区中，当TCP模块真正开始发送数据时，发送缓冲区再将这些数据封装成多个TCP报文段发出。所以TCP模块发送的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系。接收端收到一个或多个TCP报文段后，TCP将他们按照报文段的序号依次放入TCP接受的缓冲区中，并通知应用程序读取数据。接收端可以一次性将缓冲区的数据全部读出，也可以分多次，这取决于用户指定的应用程序读缓冲区的大小。所以发送端的写次数和接收端的读次数没有关系，也就是字节流的概念：**应用程序与数据的发送和接受是没有边界的**。
  - 可靠传输
    TCP协议采用发送应答机制，每发送一个都需要得到对方的应答。其次会采用超时重传，发送端在发送一个TCP报文后启动定时器，如果在定时时间内未收到应答，就会重新发送报文段。并且在接收端会依据TCP报文段的序号进行排序再交付给应用层。（之所以会乱，主要还是因为TCP报文段需要以IP数据报的形式发送，IP数据报到接受端可能会乱）

![](TCPUDP.jpg)



# 2. UDP和TCP区别

|     | TCP | UDP |
|  ----  | ----  | ----|
| 是否连接  | 面向连接 | 面向报文|
| 传输可靠性  | 可靠 | 不可靠 |
|应用场合| 传输大量数据| 传输少量数据|
|速度|慢|快|

# 3. UDP 首部格式

![](udpshujubao.jpg)

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

# 4. TCP 首部格式

![](tcpshujubao.png)
-   **源端口和目的端口**告知主机报文段来自哪里以及要传给哪个上层协议或应用程序。一般来说客户端使用系统自动选择的临时端口号，服务器使用知名服务端口号，定义在/etc/services中。

-   **序号**   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。注意，一个序号指的是同一方向上字节流的编号，返回的序号与发送的序号没有关系。

-   **确认号**   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

-   **数据偏移**   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。这里具体来说表示的是TCP头部有多少个32bit（4字节），因为4位最多能表示15，所以TCP头部最长是60字节。

-   **确认 ACK**   ：我们称携带ACK标志的TCP报文段为确认报文段，当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把ACK置 1。
-   **PSH** ：提示接收端应用程序应该立即从TCP接收缓冲区读走数据，为接受后续数据腾出空间（如果这时不将数据读走，他就会一直留在缓冲区中）
-   **复位 RST**：表示要求对方重新建立连接。
-   **同步 SYN**   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

-   **终止 FIN**   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

-   **窗口**   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，以控制对方的发送速度。
-   **TCP头部选项**   ：可变长的可选信息，这部分最多包含40字节，因为前面已经有20字节的固定部分了，而总长度是60字节。

# 5. TCP 的三次握手和四次挥手
## 5.1. TCP协议连接的建立和解除
### 5.1.1. 概念性讲解
&emsp;&emsp;TCP协议中其实并没有物理意义上上的连接，只是一种数据包的互相发送。其中三次握手指的是客户端和服务器建立连接的过程。“握手”指的是在建立连接的过程中产生的三次数据发送。首先的两次握手是最基本的。第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。

&emsp;&emsp;譬如发起请求遇到类似这样的情况：客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。如果只有两次握手，那么到这里，连接就建立了，但是此时客户端并没有任何数据要发送，而服务端还在傻傻的等候佳音，造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。

## 5.2. TCP 三次握手详解
1. 首先客户端向服务器端发送一段TCP报文，其中：
   - 标记位为SYN，表示“请求建立新连接”;
   - 序号为Seq=X（X一般为1）；
   - 随后客户端进入SYN-SENT阶段。
2. 服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：
   - 标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；
   - 序号为Seq=y；
   - 确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。
3. 客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：
   - 标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；
   - 序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；
   - 确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；
   - 随后客户端进入ESTABLISHED阶段。

4. 服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-RCVD阶段，进入ESTABLISHED阶段。

在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续"握手"，以此确保了"三次握手"的顺利完成。

此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。

![三次握手](TCP三次握手.jpg)

## 5.3. TCP四次挥手
&emsp;&emsp;四次挥手即断开连接的过程，连接的释放必须是一方主动释放，另一方被动释放。

1. 首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：
   - 标记位为FIN，表示“请求释放连接“；
   - 序号为Seq=U；
   - 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。

    注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。

2. 服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：
   - 标记位为ACK，表示“接收到客户端发送的释放连接的请求”；
   - 序号为Seq=V；
   - 确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；
   - 随后服务器端开始准备释放服务器端到客户端方向上的连接。

    客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段

    *前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了*

3. 服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：
   - 标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。
   - 序号为Seq=W；
   - 确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。

    随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。

4. 客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：
   - 标记位为ACK，表示“接收到服务器准备好释放连接的信号”。
   - 序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。
   - 确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。

    随后客户端开始在TIME-WAIT阶段等待2MSL。因为为了确认服务器端是否收到客户端发出的ACK确认报文

    当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

    服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；

    如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

    服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。

    客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。

后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。

与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续"挥手"，以此确保了"四次挥手"的顺利完成。
![](TCP四次挥手.jpg)

## 5.4. TCP状态转移
![](TCPstatus.jpg)
粗虚线表示典型的服务端连接的状态转移，粗实线表示典型的客户端连接的状态转移。

## 5.5. TIME_WAIT状态
TIME_WAIT这个状态存在的原因有两点：
1. 可靠地终止TCP连接。假设客户端发给服务器的最后一段报文丢失，那么服务器将会重发结束报文段，因此客户端需要停留在一个状态以处理服务器可能发过来的重复的报文段。
2. 保证让迟来的TCP报文段有足够的时间被识别或丢弃。这是因为在linux上一个TCP端口不能被同时打开两次以上，当一个TCP连接处于TIME_WAIT状态时，我们就无法使用这个被占用的端口来建立一个新连接。假设没有这个TIME_WAIT状态，那一个新连接进来就可以被立即创建，这个新连接与之前的拥有相同的IP和端口号，所以称它为原来的连接的化身。但是由于没有TIME_WAIT状态，所以新的化身可能收到原连接发送过来的信息，这肯定是不行的。所以必须有一个TIME_WAIT状态来让旧连接的信息要么被及时收到，要么超过TCP报文存在时间被丢弃，绝对不能让它影响到下一个连接。由于TCP报文段的最大生存时间是MSL，所以TIME_WAIT状态的持续时间就是2MSL，这样能保证没能收到的报文就能自动消失，不会影响后面的连接。

## 5.6. 为什么“握手”是三次，“挥手”却要四次？
TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？

建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。

释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

# 6. TCP 可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT" class="mathjax-pic"/></div> <br>
其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

<div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d" class="mathjax-pic"/></div> <br>
其中 RTT<sub>d</sub> 为偏差的加权平均值。

# 7. TCP 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![](tcpwindows.jpg)

# 8. TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

# 9. TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![](tcpyonsekongzhi.jpg)

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![](tcpyongsechuangkou.png)

## 9.1. 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

## 9.2. 快重传与快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![](kuaichongchaun.png)